# -*- coding: utf-8 -*-
"""
Modified on 13 Feb
@author: Stephan, Russell
"""

import json  # built-in instead of simplejson


class Description:
    __slots__ = ['SWVParameters', 'CVParameters', 'Pretreatment', 'Technique']
    
    def __init__(self):
        self.SWVParameters = ''
        self.CVParameters = ''
        self.Pretreatment = ''
        self.Technique = ''


class Unit:
    __slots__ = ['type', 's', 'c', 't', 'q', 'a']
    
    def __init__(self):
        self.type = ''
        self.s = ''
        self.c = ''
        self.t = ''
        self.q = ''
        self.a = ''


class Datavalue:
    __slots__ = ['v', 's', 'c', 't']
    
    def __init__(self):
        self.v = 0.0
        self.s = 0
        self.c = 0
        self.t = ''


class Dataset:
    __slots__ = ['type', 'values']
    
    def __init__(self):
        self.type = ''
        self.values = []


class Appearance:
    __slots__ = ['type', 'autoassigncolor', 'color', 'linewidth',
                 'symbolsize', 'symboltype', 'symbolfill', 'noline']
    
    def __init__(self):
        self.type = ''
        self.autoassigncolor = False
        self.color = ''
        self.linewidth = 0
        self.symbolsize = 0
        self.symboltype = 0
        self.symbolfill = False
        self.noline = False


class Eisdatalist:
    __slots__ = ['appearance', 'title', 'hash', 'scantype',
                 'freqtype', 'cdc', 'fitvalues', 'dataset']
    
    def __init__(self):
        self.appearance = Appearance()
        self.title = ''
        self.hash = []
        self.scantype = 0
        self.freqtype = 0
        self.cdc = object()
        self.fitvalues = object()
        self.dataset = Dataset()


class Value:
    __slots__ = ['type', 'arraytype', 'description', 'unit', 'datavalues', 'datavaluetype']
    
    def __init__(self):
        self.type = ''
        self.arraytype = 0
        self.description = ''
        self.unit = Unit()
        self.datavalues = []
        self.datavaluetype = ''


class Peaklist:
    __slots__ = ['peaktype', 'left', 'right', 'peak', 'isign']
    
    def __init__(self):
        self.peaktype = 0
        self.left = 0
        self.right = 0
        self.peak = 0
        self.isign = 0


class Xaxisdataarray:
    __slots__ = ['type', 'arraytype', 'description', 'unit', 'datavalues', 'datavaluetype']
    
    def __init__(self):
        self.type = ''
        self.arraytype = 0
        self.description = ''
        self.unit = Unit()
        self.datavalues = []
        self.datavaluetype = ''


class Yaxisdataarray:
    __slots__ = ['type', 'arraytype', 'description', 'unit', 'datavalues', 'datavaluetype']
    
    def __init__(self):
        self.type = ''
        self.arraytype = 0
        self.description = ''
        self.unit = Unit()
        self.datavalues = []
        self.datavaluetype = ''


class Curve:
    __slots__ = ['appearance', 'title', 'hash', 'type', 'xaxis', 'yaxis',
                 'xaxisdataarray', 'yaxisdataarray', 'meastype', 'peaklist',
                 'corrosionbutlervolmer', 'corrosiontafel']
    
    def __init__(self):
        self.appearance = Appearance()
        self.title = ''
        self.hash = []
        self.type = ''
        self.xaxis = 0
        self.yaxis = 0
        self.xaxisdataarray = Xaxisdataarray()
        self.yaxisdataarray = Yaxisdataarray()
        self.meastype = 0
        self.peaklist = []
        self.corrosionbutlervolmer = []
        self.corrosiontafel = []


class Measurement:
    __slots__ = ['title', 'timestamp', 'utctimestamp', 'deviceused', 'deviceserial',
                 'devicefw', 'type', 'dataset', 'method', 'curves', 'eisdatalist']
    
    def __init__(self):
        self.title = ''
        self.timestamp = object()
        self.utctimestamp = object()
        self.deviceused = 0
        we.deviceserial = ''
        self.devicefw = ''
        self.type = ''
        self.dataset = Dataset()
        self.method = ''
        self.curves = []
        self.eisdatalist = []


class Data:
    __slots__ = ['type', 'coreversion', 'methodformeasurement', 'measurements']
    
    def __init__(self):
        self.type = ''
        self.coreversion = ''
        self.methodformeasurement = ''
        self.measurements = []


class MethodType:
    __slots__ = ['CV', 'SWV', 'EIS']
    
    def __init__(self):    
        self.CV = 'CV'
        self.SWV = 'SWV'
        self.EIS = 'EIS'


class axis:
    __slots__ = ['xvalues', 'yvalues']
    
    def __init__(self):
        self.xvalues = []
        self.yvalues = []


class EISMeasurement:
    __slots__ = ['freq', 'zdash', 'potential', 'zdashneg', 'Z', 'phase', 'current',
                 'npoints', 'tint', 'ymean', 'debugtext', 'Y', 'YRe', 'YIm',
                 'scale', 'Cdash', 'Cdashdash']
    
    def __init__(self):
        self.freq = []
        self.zdash = []
        self.potential = []
        self.zdashneg = []
        self.Z = []
        self.phase = []
        self.current = []
        self.npoints = []
        self.tint = []
        self.ymean = []
        self.debugtext = []
        self.Y = []
        self.YRe = []
        self.YIm = []
        self.Cdash = []
        self.Cdashdash = []
        self.scale = 100000  # standard set to mega ohms


class jparse:    
    @property
    def experimentList(self):
        return self._experimentList
    
    @property
    def parsedData(self):
        return self._parsedData
    
    @property
    def data(self):
        return self._data
    
    def __init__(self, filename_list):
        # filename_list is expected to be an iterable of paths
        self._methodType = MethodType()
        self._experimentList = []
        self.files = []
        self.experimentToFileMap = {}
        self._parsedData = self._parse(filename_list)
        self.experimentIndex = 0
        self._data = self._simplify()
        
    def _parse(self, filenames):
        # takes in the files
        # parses the raw data to an object
        # simplifies the values and adds it to the 'data' object
        
        self._getFilenames(filenames)
        
        try:
            index = 0
            readData = {}
            for filename in filenames:
                f = open(filename, "rb")
                readData[self.files[index]] = (
                    f.read()
                     .decode('utf-16')
                     .replace('\r\n', ' ')
                     .replace(':true', r':"True"')
                     .replace(':false', r':"False"')
                )
                index = index + 1
                f.close()
        except Exception as e:
            print('Could not find or open file: ' + str(filename), e)
            return
            
        try:
            parsedData = {}
            for file in self.files:
                # has a weird character at the end
                data2 = readData[file][0:(len(readData[file]) - 1)]
                # parse to nested dicts
                parsedData[file] = json.loads(data2)
        except Exception as e:
            print('Failed to parse string to JSON', e)
            return
        
        try:
            for file in self.files:
                print("Top-level keys in", file, ":", parsedData[file].keys())
                if 'measurements' not in parsedData[file]:
                    print("No 'measurements' key in", file)
                    continue
                for measurement in parsedData[file]['measurements']:
                    currentMethod = self._getMethodType(measurement.get('method', ''))
                    currentMethod = currentMethod.upper()
                    index = len([
                        i for i, s in enumerate(self._experimentList)
                        if currentMethod in s
                    ])
                    self._experimentList.append(currentMethod + ' ' + str(index + 1))
        except Exception as e:
            print("Failed to generate property: experimentList 'measurements'", e)
            return

        return parsedData
    
    def _simplify(self):
        simplifiedData = {}
        experimentIndex = 0
        for file in self.files:
            rawData = self._parsedData[file]
            if 'measurements' not in rawData:
                print("No 'measurements' key in rawData for", file)
                continue
            for measurement in rawData['measurements']:
                currentMethod = self._getMethodType(measurement.get('method', ''))
                currentMethod = currentMethod.upper()
                if currentMethod in self._methodType.SWV or currentMethod in self._methodType.CV:
                    simplifiedData[self._experimentList[experimentIndex]] = self._getXYDataPoints(measurement)
                    simplifiedData[self._experimentList[experimentIndex] + ' Details'] = self._getXYUnits(measurement)
                if currentMethod in self._methodType.EIS:
                    simplifiedData[self._experimentList[experimentIndex]] = self._getEISDataPoints(measurement)
                self.experimentToFileMap[self._experimentList[experimentIndex]] = file
                experimentIndex = experimentIndex + 1
        return simplifiedData
    
    def _getXYUnits(self, measurement):
        unit = {}
        try:
            curve0 = measurement['curves'][0]
            xtext = curve0['xaxisdataarray']['unit']['type']
            ytext = curve0['yaxisdataarray']['unit']['type']
            if xtext is not None:
                unit['x'] = self._unitTextToScale(xtext)
                unit['y'] = self._unitTextToScale(ytext)
            unit['title'] = measurement['title']
        except Exception as e:
            print('Exception when processing units for SWV or CV.', e)
            unit = {}
        return unit
        
    def _unitTextToScale(self, text):
        unit = {}
        unit['scale'] = 1
        unit['unit'] = ''
        
        if 'Milli' in text:
            unit['scale'] = 1000
            unit['unit'] = 'm'
        if 'Micro' in text:
            unit['scale'] = 1000000
            unit['unit'] = "\u03BC"
        if 'Nano' in text:
            unit['scale'] = 1000000000
            unit['unit'] = 'n'
        if 'Pico' in text:
            unit['scale'] = 1000000000000
            unit['unit'] = 'p'
            
        return unit
    
    def _getXYDataPoints(self, measurement):
        ax = axis()
        for curve in measurement['curves']:
            pos = 0
            for y in curve['yaxisdataarray']['datavalues']:
                ax.xvalues.append(curve['xaxisdataarray']['datavalues'][pos]['v'])
                ax.yvalues.append(y['v'])
                pos = pos + 1
        return ax
    
    def _getEISDataPoints(self, measurement):
        eisdata = EISMeasurement()
        for eis in measurement['eisdatalist']:
            for value in eis['dataset']['values']:
                unit = value.get('unit')
                if unit is not None and unit.get('q') is not None:
                    q = unit['q']
                    v = [c['v'] for c in value['datavalues']]
                    if q == "Frequency":
                        eisdata.freq = v
                    if q == "Z'":
                        eisdata.zdash = v
                    if q == "Potential'":
                        eisdata.potential = v
                    if q == "-Z''":
                        eisdata.zdashneg = v
                    if q == "Z":
                        eisdata.Z = v
                    if q == "-Phase":
                        eisdata.phase = v
                    if q == "npoints":
                        eisdata.npoints = v
                    if q == "tint":
                        eisdata.tint = v
                    if q == "ymean":
                        eisdata.ymean = v
                    if q == "debugtext":
                        eisdata.debugtext = v
                    if q == "Y":
                        eisdata.Y = v
                    if q == "Y'":
                        eisdata.YRe = v
                    if q == "Y''":
                        eisdata.YIm = v
                        
        pos = 0
        cd = []
        cdd = []
        for zdd in eisdata.zdashneg:
            denom = 2 * 3.141592653589793 * eisdata.freq[pos] * (
                eisdata.zdash[pos] * eisdata.zdash[pos] +
                eisdata.zdashneg[pos] * eisdata.zdashneg[pos]
            )
            cdd.append(zdd / denom)
            cd.append(eisdata.zdash[pos] / denom)
            pos += 1
        
        eisdata.Cdash = cd
        eisdata.Cdashdash = cdd
        
        return eisdata
            
    def _getFilenames(self, files):
        for f in files:
            parts = f.split('\\')
            name = parts[len(parts) - 1].replace('.pssession', '')
            self.files.append(name)
                
    def _getMethodType(self, method):
        methodName = ''
        splitted = method.split("\r\n")
        for line in splitted:
            if "METHOD_ID" in line:
                methodName = line.split("=")[1]
        return methodName
    
    def inFile(self, experimentLabel):
        if experimentLabel in self.experimentToFileMap:
            print(experimentLabel + ' is in ' +
                  self.experimentToFileMap[experimentLabel] + ".pssession")
